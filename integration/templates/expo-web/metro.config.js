/**
 * DO NOT EDIT THIS FILE UNLESS YOU DEFINITELY KNOW WHAT YOU ARE DOING.
 * THIS ENSURES THAT INTEGRATION TESTS ARE LOADING THE CORRECT DEPENDENCIES.
 */
const { getDefaultConfig } = require('expo/metro-config');
const packageJson = require('./package.json');
const path = require('node:path');

/** @type {() => string | undefined} */
const getClerkExpoPath = () => {
  const clerkExpoPath = packageJson.dependencies['@clerk/expo'];

  if (clerkExpoPath?.startsWith('*')) {
    const pathToModule = require.resolve('@clerk/expo');
    return pathToModule.replace('dist/index.js', '');
  }

  if (clerkExpoPath?.startsWith('file:')) {
    return clerkExpoPath.replace('file:', '');
  }

  if (clerkExpoPath?.startsWith('link:')) {
    return clerkExpoPath.replace('link:', '');
  }

  return undefined;
};

const clerkExpoPath = getClerkExpoPath();
const clerkMonorepoPath = clerkExpoPath?.replace(/\/packages\/expo$/, '');

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);

// Only customize Metro config when running from monorepo
if (clerkMonorepoPath) {
  console.log('[Metro Config] Applying monorepo customizations');
  config.watchFolders = [clerkMonorepoPath];

  // Disable file watching to prevent infinite reload loops in integration tests
  config.watchFolders = [clerkMonorepoPath];
  config.watcher = {
    healthCheck: {
      enabled: false,
    },
  };

  // Prioritize local node_modules over monorepo node_modules
  config.resolver.nodeModulesPaths = [path.resolve(__dirname, 'node_modules'), `${clerkMonorepoPath}/node_modules`];

  // Explicitly map @clerk packages to their source locations
  // Point to the root of the package so Metro can properly resolve subpath exports
  config.resolver.extraNodeModules = {
    '@clerk/react': path.resolve(clerkMonorepoPath, 'packages/react'),
    '@clerk/expo': path.resolve(clerkMonorepoPath, 'packages/expo'),
    '@clerk/shared': path.resolve(clerkMonorepoPath, 'packages/shared'),
    '@clerk/types': path.resolve(clerkMonorepoPath, 'packages/types'),
  };

  // This is a workaround to prevent multiple versions of react and react-native from being loaded.
  // Block React/React-Native in both monorepo root and all package node_modules
  // Use word boundaries to avoid blocking clerk-react
  // https://github.com/expo/expo/pull/26209
  const escapedPath = clerkMonorepoPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  config.resolver.blockList = [
    // Block monorepo root node_modules for react/react-native/react-dom
    new RegExp(`${escapedPath}/node_modules/react/`),
    new RegExp(`${escapedPath}/node_modules/react$`),
    new RegExp(`${escapedPath}/node_modules/react-dom/`),
    new RegExp(`${escapedPath}/node_modules/react-dom$`),
    new RegExp(`${escapedPath}/node_modules/react-native/`),
    new RegExp(`${escapedPath}/node_modules/react-native$`),
    // Block react in monorepo's pnpm store
    new RegExp(`${escapedPath}/node_modules/\\.pnpm/.*/node_modules/react/`),
    new RegExp(`${escapedPath}/node_modules/\\.pnpm/.*/node_modules/react$`),
    new RegExp(`${escapedPath}/node_modules/\\.pnpm/.*/node_modules/react-dom/`),
    new RegExp(`${escapedPath}/node_modules/\\.pnpm/.*/node_modules/react-dom$`),
    new RegExp(`${escapedPath}/node_modules/\\.pnpm/.*/node_modules/react-native/`),
    new RegExp(`${escapedPath}/node_modules/\\.pnpm/.*/node_modules/react-native$`),
    // Block react/react-native/react-dom in all package node_modules
    new RegExp(`${escapedPath}/packages/.*/node_modules/react/`),
    new RegExp(`${escapedPath}/packages/.*/node_modules/react$`),
    new RegExp(`${escapedPath}/packages/.*/node_modules/react-dom/`),
    new RegExp(`${escapedPath}/packages/.*/node_modules/react-dom$`),
    new RegExp(`${escapedPath}/packages/.*/node_modules/react-native/`),
    new RegExp(`${escapedPath}/packages/.*/node_modules/react-native$`),
  ];

  // Custom resolver to handle package.json subpath exports for @clerk packages
  // This enables Metro to resolve imports like '@clerk/react/internal'
  const originalResolveRequest = config.resolver.resolveRequest;
  config.resolver.resolveRequest = (context, moduleName, platform) => {
    // Check if this is a @clerk package with a subpath
    const clerkPackageMatch = moduleName.match(/^(@clerk\/[^/]+)\/(.+)$/);
    if (clerkPackageMatch && config.resolver.extraNodeModules) {
      const [, packageName, subpath] = clerkPackageMatch;
      const packageRoot = config.resolver.extraNodeModules[packageName];

      if (packageRoot) {
        // Try to resolve via the subpath-workaround directory (e.g., internal/package.json)
        const subpathDir = path.join(packageRoot, subpath);
        try {
          const subpathPkg = require(path.join(subpathDir, 'package.json'));
          if (subpathPkg.main) {
            const resolvedPath = path.join(subpathDir, subpathPkg.main);
            return { type: 'sourceFile', filePath: resolvedPath };
          }
        } catch (e) {
          // Subpath directory doesn't exist, continue with default resolution
        }
      }
    }

    // Fall back to default resolution
    if (originalResolveRequest) {
      return originalResolveRequest(context, moduleName, platform);
    }
    return context.resolveRequest(context, moduleName, platform);
  };
}

module.exports = config;
