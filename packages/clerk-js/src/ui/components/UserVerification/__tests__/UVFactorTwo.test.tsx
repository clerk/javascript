import { describe, it } from '@jest/globals';
import { waitFor } from '@testing-library/react';

import { render, runFakeTimers } from '../../../../testUtils';
import { clearFetchCache } from '../../../hooks';
import { bindCreateFixtures } from '../../../utils/test/createFixtures';
import { UserVerificationFactorTwo } from '../UserVerificationFactorTwo';

const { createFixtures } = bindCreateFixtures('UserVerification');

describe('UserVerificationFactorTwo', () => {
  /**
   * `<UserVerificationFactorOne/>` internally uses useFetch which caches the results, be sure to clear the cache before each test
   */
  beforeEach(() => {
    clearFetchCache();
  });

  it('renders the component for with strategy:phone_code', async () => {
    const { wrapper, fixtures } = await createFixtures(f => {
      f.withUser({ username: 'clerkuser' });
    });
    fixtures.session?.startVerification.mockResolvedValue({
      status: 'needs_second_factor',
      supportedSecondFactors: [{ strategy: 'phone_code' }],
    });

    fixtures.session?.prepareSecondFactorVerification.mockResolvedValue({
      status: 'needs_second_factor',
      supportedSecondFactors: [{ strategy: 'phone_code' }],
    });

    const { getByText, getAllByLabelText } = render(<UserVerificationFactorTwo />, { wrapper });

    await waitFor(() => {
      getByText('Verification required');
      const inputs = getAllByLabelText(/digit/i);
      expect(inputs.length).toBe(6);
    });
  });

  it('renders the component for with strategy:totp', async () => {
    const { wrapper, fixtures } = await createFixtures(f => {
      f.withUser({ username: 'clerkuser' });
    });
    fixtures.session?.startVerification.mockResolvedValue({
      status: 'needs_second_factor',
      supportedSecondFactors: [{ strategy: 'totp' }],
    });

    fixtures.session?.prepareSecondFactorVerification.mockResolvedValue({
      status: 'needs_second_factor',
      supportedSecondFactors: [{ strategy: 'totp' }],
    });
    const { getByLabelText, getByText } = render(<UserVerificationFactorTwo />, { wrapper });

    await waitFor(() => {
      getByText('Verification required');
      getByText('Enter the code generated by your authenticator app to continue');
      getByLabelText(/Enter verification code/i);
    });
  });

  it('renders the component for with strategy:backup_code', async () => {
    const { wrapper, fixtures } = await createFixtures(f => {
      f.withUser({ username: 'clerkuser' });
    });
    fixtures.session?.startVerification.mockResolvedValue({
      status: 'needs_second_factor',
      supportedSecondFactors: [{ strategy: 'backup_code' }],
    });

    fixtures.session?.prepareSecondFactorVerification.mockResolvedValue({
      status: 'needs_second_factor',
      supportedSecondFactors: [{ strategy: 'backup_code' }],
    });
    const { getByLabelText, getByText } = render(<UserVerificationFactorTwo />, { wrapper });

    await waitFor(() => {
      getByText('Enter a backup code');
      getByText('Enter the backup code you received when setting up two-step authentication');
      getByLabelText(/Backup code/i);
    });
  });

  describe('Navigation', () => {
    it('navigates to UserVerificationFactorOne component if user lands on SignInFactorTwo page but they should not', async () => {
      const { wrapper, fixtures } = await createFixtures(f => {
        f.withUser({ username: 'clerkuser' });
      });
      fixtures.session?.startVerification.mockResolvedValue({
        status: 'needs_first_factor',
      });
      render(<UserVerificationFactorTwo />, { wrapper });

      await waitFor(() => expect(fixtures.router.navigate).toHaveBeenCalledWith('../'));
    });
  });

  describe('Submitting', () => {
    it('sets an active session when user submits second factor successfully', async () => {
      const { wrapper, fixtures } = await createFixtures(f => {
        f.withUser({ username: 'clerkuser' });
      });
      fixtures.session?.startVerification.mockResolvedValue({
        status: 'needs_second_factor',
        supportedSecondFactors: [{ strategy: 'phone_code' }],
      });

      fixtures.session?.prepareSecondFactorVerification.mockResolvedValue({
        status: 'needs_second_factor',
        supportedSecondFactors: [{ strategy: 'phone_code' }],
      });

      fixtures.session?.attemptSecondFactorVerification.mockResolvedValue({
        status: 'complete',
        supportedSecondFactors: [],
        session: {
          id: '123',
        },
      });

      await runFakeTimers(async timers => {
        const { userEvent, getByLabelText, getByText } = render(<UserVerificationFactorTwo />, { wrapper });

        await waitFor(() => getByText('Verification required'));

        await userEvent.type(getByLabelText(/Enter verification code/i), '123456');
        timers.runOnlyPendingTimers();
        await waitFor(() => {
          expect(fixtures.clerk.setActive).toHaveBeenCalled();
        });
      });
    });
  });

  describe('Use another second factor method', () => {
    it('should list enabled second factor methods without the current one', async () => {
      const { wrapper, fixtures } = await createFixtures(f => {
        f.withUser({ username: 'clerkuser' });
      });
      fixtures.session?.startVerification.mockResolvedValue({
        status: 'needs_second_factor',
        supportedSecondFactors: [
          {
            strategy: 'phone_code',
            phoneNumberId: 'phone_1',
            safeIdentifier: '+3069XXXXXXX1',
          },
          {
            strategy: 'phone_code',
            phoneNumberId: 'phone_2',
            safeIdentifier: '+3069XXXXXXX2',
          },
        ],
      });
      fixtures.session?.prepareSecondFactorVerification.mockResolvedValue({});

      const { getByText, getByRole } = render(<UserVerificationFactorTwo />, { wrapper });

      await waitFor(() => {
        getByText('Verification required');
        getByText('Use another method');
      });

      await waitFor(() => {
        getByText('Use another method').click();
        expect(getByRole('button')).toHaveTextContent('Send SMS code to +3069XXXXXXX1');
        expect(getByRole('button')).not.toHaveTextContent('Send SMS code to +3069XXXXXXX2');
      });
    });

    it.skip('can select another method', async () => {
      const { wrapper, fixtures } = await createFixtures(f => {
        f.withUser({ username: 'clerkuser' });
      });
      fixtures.session?.startVerification.mockResolvedValue({
        status: 'needs_second_factor',
        supportedSecondFactors: [
          {
            strategy: 'phone_code',
            phoneNumberId: 'phone_1',
            safeIdentifier: '+3069XXXXXXX1',
          },
          {
            strategy: 'phone_code',
            phoneNumberId: 'phone_2',
            safeIdentifier: '+3069XXXXXXX2',
          },
        ],
      });
      fixtures.session?.prepareSecondFactorVerification.mockResolvedValue({});

      const { getByText, container } = render(<UserVerificationFactorTwo />, { wrapper });

      await waitFor(() => {
        getByText('Verification required');
        expect(container).toHaveTextContent('+3069XXXXXXX1');
        expect(container).not.toHaveTextContent('+3069XXXXXXX2');
        getByText('Use another method');
      });

      await waitFor(() => {
        getByText('Use another method').click();
        getByText('Send SMS code to +3069XXXXXXX2').click();
      });

      await waitFor(() => {
        getByText('Verification required');
        expect(container).toHaveTextContent('+3069XXXXXXX2');
      });
    });
  });

  describe('Get Help', () => {
    it.todo('should render the get help component when clicking the "Get Help" button');
  });
});
