import { describe, it } from '@jest/globals';
import { waitFor } from '@testing-library/react';

import { render, runFakeTimers } from '../../../../testUtils';
import { clearFetchCache } from '../../../hooks';
import { bindCreateFixtures } from '../../../utils/test/createFixtures';
import { UserVerificationFactorTwo } from '../UserVerificationFactorTwo';

const { createFixtures } = bindCreateFixtures('UserVerification');

describe('UserVerificationFactorTwo', () => {
  /**
   * `<UserVerificationFactorOne/>` internally uses useFetch which caches the results, be sure to clear the cache before each test
   */
  beforeEach(() => {
    clearFetchCache();
  });

  it('renders the component for with strategy:phone_code', async () => {
    const { wrapper, fixtures } = await createFixtures(f => {
      f.withUser({ username: 'clerkuser' });
    });
    fixtures.user?.__experimental_verifySession.mockResolvedValue({
      status: 'needs_second_factor',
      supportedSecondFactors: [{ strategy: 'phone_code' }],
    });

    fixtures.user?.__experimental_verifySessionPrepareSecondFactor.mockResolvedValue({
      status: 'needs_second_factor',
      supportedSecondFactors: [{ strategy: 'phone_code' }],
    });

    const { getByText, getAllByLabelText } = render(<UserVerificationFactorTwo />, { wrapper });

    await waitFor(() => {
      getByText('Check your phone');
      const inputs = getAllByLabelText(/digit/i);
      expect(inputs.length).toBe(6);
    });
  });

  it('renders the component for with strategy:totp', async () => {
    const { wrapper, fixtures } = await createFixtures(f => {
      f.withUser({ username: 'clerkuser' });
    });
    fixtures.user?.__experimental_verifySession.mockResolvedValue({
      status: 'needs_second_factor',
      supportedSecondFactors: [{ strategy: 'totp' }],
    });

    fixtures.user?.__experimental_verifySessionPrepareSecondFactor.mockResolvedValue({
      status: 'needs_second_factor',
      supportedSecondFactors: [{ strategy: 'totp' }],
    });
    const { getByLabelText, getByText } = render(<UserVerificationFactorTwo />, { wrapper });

    await waitFor(() => {
      getByText('Two-step verification');
      getByText('To continue, please enter the verification code generated by your authenticator app');
      getByLabelText(/Enter verification code/i);
    });
  });

  it('renders the component for with strategy:backup_code', async () => {
    const { wrapper, fixtures } = await createFixtures(f => {
      f.withUser({ username: 'clerkuser' });
    });
    fixtures.user?.__experimental_verifySession.mockResolvedValue({
      status: 'needs_second_factor',
      supportedSecondFactors: [{ strategy: 'backup_code' }],
    });

    fixtures.user?.__experimental_verifySessionPrepareSecondFactor.mockResolvedValue({
      status: 'needs_second_factor',
      supportedSecondFactors: [{ strategy: 'backup_code' }],
    });
    const { getByLabelText, getByText } = render(<UserVerificationFactorTwo />, { wrapper });

    await waitFor(() => {
      getByText('Enter a backup code');
      getByText('Your backup code is the one you got when setting up two-step authentication.');
      getByLabelText(/Backup code/i);
    });
  });

  describe('Navigation', () => {
    it('navigates to UserVerificationFactorOne component if user lands on SignInFactorTwo page but they should not', async () => {
      const { wrapper, fixtures } = await createFixtures(f => {
        f.withUser({ username: 'clerkuser' });
      });
      fixtures.user?.__experimental_verifySession.mockResolvedValue({
        status: 'needs_first_factor',
      });
      render(<UserVerificationFactorTwo />, { wrapper });

      await waitFor(() => expect(fixtures.router.navigate).toHaveBeenCalledWith('../'));
    });
  });

  describe('Submitting', () => {
    it('sets an active session when user submits second factor successfully', async () => {
      const { wrapper, fixtures } = await createFixtures(f => {
        f.withUser({ username: 'clerkuser' });
      });
      fixtures.user?.__experimental_verifySession.mockResolvedValue({
        status: 'needs_second_factor',
        supportedSecondFactors: [{ strategy: 'phone_code' }],
      });

      fixtures.user?.__experimental_verifySessionPrepareSecondFactor.mockResolvedValue({
        status: 'needs_second_factor',
        supportedSecondFactors: [{ strategy: 'phone_code' }],
      });

      fixtures.user?.__experimental_verifySessionAttemptSecondFactor.mockResolvedValue({
        status: 'complete',
        supportedSecondFactors: [],
        session: {
          id: '123',
        },
      });

      await runFakeTimers(async timers => {
        const { userEvent, getByLabelText, getByText } = render(<UserVerificationFactorTwo />, { wrapper });

        await waitFor(() => getByText('Check your phone'));

        await userEvent.type(getByLabelText(/Enter verification code/i), '123456');
        timers.runOnlyPendingTimers();
        await waitFor(() => {
          expect(fixtures.clerk.setActive).toHaveBeenCalled();
        });
      });
    });
  });

  describe('Use another method', () => {
    it.todo('should list enabled second factor methods without the current one');
  });

  describe('Get Help', () => {
    it.todo('should render the get help component when clicking the "Get Help" button');
  });
});
